@page "/Progress"

@rendermode InteractiveServer

@if (isLoaded is false)
{
    <Loading />
}
else
{
    <header class="main-header">
        @if (firstQuestion is false)
        {
            <button @onclick="PreviousQuestion">
                <img src="/back.svg" />
            </button>
        }
        <h4 class="header-title">بخش @SectionNumber</h4>
    </header>
    <div class="question-wrapper">
        @if (isDescription is true && alreadyDescribed is false)
        {
            <QuestionnaireDescriptionCard QuestionnaireId="questionnaire!.Id" OnContinue="HandleContinue" />
        }
        else
        {
            <QuestionCard QuestionId="QuestionId" ParticipantId="participant!.Id" OnAnswered="HandleAnswer" />
        }
    </div>
    <footer>
        <ProgressBar ResponsesCount="@ResponsesCount" />
    </footer>
}

@code {
    private Participant? participant;

    private List<Questionnaire>? Questionnaires;
    private List<Question>? Questions;

    private Guid? QuestionId;
    private Question? question;
    private Questionnaire? questionnaire;

    private int? SectionNumber;
    private int ResponsesCount = 0;

    private bool firstQuestion = false;
    private bool shouldRender = true;

    private bool isLoaded = false;
    private bool isDescription = false;
    private bool alreadyDescribed = false;

    private bool isPrevious = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        using var context = DbContextFactory.CreateDbContext();

        if (firstRender)
        {
            var participantId = await getParticipantId();
            if (participantId is null)
            {
                NavigationManager.NavigateTo("/", true);
                return;
            }

            participant ??= await context.Participants
                .FirstOrDefaultAsync(p => p.Id.ToString() == participantId);
            if (participant is null)
            {
                await localStorage.ClearAsync();
                NavigationManager.NavigateTo("/", true);
                return;
            }

            firstRender = false;
        }

        if (shouldRender)
        {
            // Load Responses List
            var responsesList = await getParticipantResponses();

            // Finish if Complete Then Redirect to Thanks
            var isCompleted = await checkIfCompleted();
            if (isCompleted)
            {
                await FinalizeQuestionnaire();
                return;
            }

            // Continue if it is not Complete
            if (isPrevious)
            {
                QuestionId = await getPreviusQuestionId(QuestionId);
                alreadyDescribed = true;
                isPrevious = false;
            }
            else
            {
                QuestionId = await getNextQuestionId(responsesList!);
            }
            if (QuestionId is null)
            {
                await FinalizeQuestionnaire();
                return;
            }

            // Display First Question After Last Response
            isDescription = await checkIfIsDescription(QuestionId);
            if (isDescription is true)
            {
                questionnaire = await getQuestionnaire(QuestionId);
            }

            isLoaded = true;
            shouldRender = false;

            StateHasChanged();
        }
    }

    private async Task<string?> getParticipantId()
    {
        var participantId = await localStorage.GetItemAsync<string>("participantId");
        return participantId;
    }

    private async Task<List<Response>?> getParticipantResponses()
    {
        using var context = DbContextFactory.CreateDbContext();
        var responses = await context.Responses
            .Include(m => m.Question)
                .ThenInclude(m => m.Questionnaire)
            .Where(m => m.ParticipantId == participant!.Id)
            .OrderBy(m => m.Question.Position)
            .OrderBy(m => m.Question.Questionnaire.Priority)
            .ToListAsync();
        ResponsesCount = responses.Count();
        return responses;
    }

    private async Task<bool> checkIfCompleted()
    {
        using var context = DbContextFactory.CreateDbContext();
        var questionsCount = await context.Questions
            .CountAsync();
        return ResponsesCount >= questionsCount;
    }

    private async Task<Guid?> getPreviusQuestionId(Guid? currentQuestionId)
    {
        using var context = DbContextFactory.CreateDbContext();
        var currentQuestion = await context.Questions
            .Include(m => m.Questionnaire)
            .FirstOrDefaultAsync(m => m.Id == currentQuestionId);
        var questionPosition = currentQuestion!.Position;
        var questionnairePriority = currentQuestion!.Questionnaire.Priority;
        if(questionPosition > 1)
        {
            questionPosition -= 1;
        }
        else
        {
            questionnairePriority -= 1;
            questionPosition = await context.Questions
                .Include(m => m.Questionnaire)
                .Where(m => m.Questionnaire.Priority == questionnairePriority)
                .MaxAsync(m => m.Position);
        }
        var previousQuestion = await context.Questions
            .Include(m => m.Questionnaire)
            .Where(m => m.Questionnaire.Priority == questionnairePriority)
            .FirstOrDefaultAsync(m => m.Position == questionPosition);
        firstQuestion = (questionPosition == 1 && questionnairePriority == 1);
        return previousQuestion!.Id;
    }

    private async Task<Guid?> getNextQuestionId(List<Response>? responses)
    {
        using var context = DbContextFactory.CreateDbContext();
        firstQuestion = responses!.Count == 0;
        var lastResponse = responses!.Count == 0 ? null : responses!.Last();
        var questionnairePriority = lastResponse is not null
            ? lastResponse.Question.Questionnaire.Priority
            : 1;
        var questionPosition = lastResponse is not null
            ? lastResponse.Question.Position
            : 0;
        var nextQuestion = await context.Questions
            .Include(m => m.Questionnaire)
            .Where(m => m.Questionnaire.Priority == questionnairePriority)
            .FirstOrDefaultAsync(m => m.Position == questionPosition + 1);
        if (nextQuestion is not null)
        {
            SectionNumber = nextQuestion.Questionnaire.Priority;
            return nextQuestion.Id;
        }
        nextQuestion = await context.Questions
            .Include(m => m.Questionnaire)
            .Where(m => m.Questionnaire.Priority == questionnairePriority + 1)
            .FirstOrDefaultAsync(m => m.Position == 1);
        if (nextQuestion is not null)
        {
            SectionNumber = nextQuestion.Questionnaire.Priority;
            return nextQuestion.Id;
        }
        return null;
    }

    private async Task<bool> checkIfIsDescription(Guid? questionId)
    {
        using var context = DbContextFactory.CreateDbContext();
        var question = await context.Questions
            .FirstOrDefaultAsync(m => m.Id == questionId);
        var position = question!.Position;
        return position == 1;
    }

    private async Task<Questionnaire?> getQuestionnaire(Guid? questionId)
    {
        using var context = DbContextFactory.CreateDbContext();
        var question = await context.Questions
            .Include(m => m.Questionnaire)
            .FirstOrDefaultAsync(m => m.Id == questionId);
        return question!.Questionnaire;
    }

    private async Task FinalizeQuestionnaire()
    {
        await localStorage.ClearAsync();
        NavigationManager.NavigateTo("/Thanks", true);
        return;
    }

    private async Task PreviousQuestion()
    {
        isLoaded = false;
        isPrevious = true;
        shouldRender = true;
        StateHasChanged();
    }

    private async Task HandleAnswer()
    {
        alreadyDescribed = false;
        isLoaded = false;
        shouldRender = true;
        StateHasChanged();
    }

    private void HandleContinue()
    {
        alreadyDescribed = true;
        shouldRender = true;
        StateHasChanged();
    }
}
